{"name":"Darpule","tagline":"Lightweight, robust immutable tuple implementation.","body":"# Darpule\r\n\r\n_Lightweight, Robust Immutable Tuple Implementation._\r\n\r\n[![codecov.io](https://codecov.io/github/rayk/darpule/coverage.svg?branch=master)](https://codecov.io/github/rayk/darpule?branch=master)   [![Build Status](https://travis-ci.org/rayk/darpule.svg?branch=release)](https://travis-ci.org/rayk/darpule)\r\n\r\nThe [tuple](https://en.wikipedia.org/wiki/Tuple) has been knocking around for a long time, with implementations in Python, Lisp, Scala, Linda and many other languages it is the workhorse for sling data around between functions.\r\n\r\nImmutability certain helps with persistence and being able to send it to an Isolate without the serialising and marshalling is handy.\r\n\r\nThis package addresses the base use case, which is the passing of multiple parameters and results in a clean, structured way, via a Tuple. The implementation wraps all the Dart Goodness to deliver lightweight implementation was possible.  \r\n\r\n### Usage Examples\r\n\r\n_The code below can be run from examples/darpule.dart._\r\n\r\nOne easy way to create an immutable tuple with _n_ elements. Using a single generative constructor, development time type checking was deliberately traded off. Insteadof using generics to parametrise multiple Tuple types, functional predicates where used for dynamic runtime type checking.\r\n\r\n```dart\r\n    /// Created in a very ad-hoc.\r\n    \r\n    List resultFromSomeWhere = ['Longhaul', 382, 982.23, false];\r\n    \r\n    Tuple payload = new Tuple(resultFromSomeWhere);\r\n    \r\n    assert(payload is Tuple);\r\n    assert(payload.type == TupleType.quadruple);\r\n    assert(payload.elementCount == 4);\r\n    \r\n    /// Tuple can hold anything.\r\n    Tuple collective = new Tuple([\r\n      true,\r\n      new Tuple([343, false]),\r\n      new DateTime.now()\r\n    ]);\r\n    \r\n    assert(collective is Tuple);\r\n    assert(collective.type == TupleType.triple);\r\n    \r\n```\r\n\r\nSo as not to reinvent the wheel the Tuple type just extends Dart's [UnmodifiableListView](https://api.dartlang.org/134830/dart-collection/UnmodifiableListView-class.html), which has a reasonably small footprint. This provides the iterator goodness for locating stuff.\r\n\r\nYou can also just call the Tuple instance, and it returns a list of its elements that you can modify in any way. When ready, pass that list back into a Tuple constructor, and we have a new immutable Tuple.\r\n\r\n```dart\r\n    /// Ways to get a tuple elements\r\n    \r\n    Tuple notSameContent = new Tuple([8827, 'sad']);\r\n\r\n    assert(collective[0] == true); // Using element position number.\r\n    \r\n    List tupleContent = notSameContent(); // Call your tuple like a function.\r\n    \r\n    assert(tupleContent[0] == 8827 && tupleContent[1] == 'sad');\r\n    \r\n    tupleContent.add('Now we can mutate the resulting list');\r\n    \r\n    Tuple notSameContentWithMore = new Tuple(tupleContent); // Back to a tuple.\r\n    \r\n    assert (notSameContentWithMore is Tuple);\r\n    assert (notSameContent.type == TupleType.pairple);\r\n    assert (notSameContentWithMore.type == TupleType.triple);\r\n```\r\n\r\nBeside UnmodifiableList View not supporting mutations, we have introduced an [MutabilityError] just so you can blow up when something attempts mutate your tuple.\r\n```dart\r\n    /// Tuple is Immutable, trying results in an programming error.\r\n  \r\n    try {\r\n      payload.add('WantToAddElement');\r\n    } catch (error) {\r\n      assert(error is MutabilityError);\r\n    }\r\n  \r\n    try {\r\n      payload.addAll(['doctor', 'drugs']);\r\n    } catch (error) {\r\n      assert(error is MutabilityError);\r\n    }\r\n  \r\n    try {\r\n      payload.removeAt(0);\r\n    } catch (error) {\r\n      assert (error is MutabilityError);\r\n    }\r\n```\r\n \r\nEqual is based upon the content and structure of the tuple.\r\n\r\n```dart\r\n    /// Hash and Equals behaviour\r\n\r\n    assert(collective != payload);\r\n    \r\n    Tuple sameContent1 = new Tuple([3902, 'happy']);\r\n    Tuple sameContent2 = new Tuple([3902, 'happy']);\r\n    \r\n    assert(sameContent1 == sameContent2); // They have same elements.\r\n    assert(identical(sameContent1, sameContent2) == false); // But are unique.\r\n    \r\n    Tuple notSameContent = new Tuple([8827, 'sad']);\r\n    \r\n    Tuple deepLikeness = new Tuple(['skindeep', sameContent1]);\r\n    Tuple deeperLikeness = new Tuple(['skindeep', sameContent1]);\r\n    Tuple downDeep = new Tuple(['skindeep', notSameContent]);\r\n    \r\n    assert(deepLikeness == deeperLikeness);\r\n    assert(downDeep != deepLikeness);\r\n```\r\n\r\nThis is all very nice and neat, but the only type we have is 'Tuple'. This is where predicates come into play. It easily to become a Tupleholic and when you end up with functions that accept any Tuple, a real mess can appear overnight, so probably best to keep them away from the surface areas of API's. To afford some protection at runtime there is the Predicate library, given a Tuple is a glorified list of typed elements, functions can be composed together to achieve anything.\r\n\r\nWithout importing the predicate library, you can use the [elementTypesOf(Tuple tuple)] to get the [Type] of each of the elements.\r\n\r\n```dart\r\n    /// Finding out what the elements are at runtime.\r\n\r\n    Tuple typesInPayload = elementTypesOf(payload);\r\n    \r\n    assert(typesInPayload[0] == String );\r\n    assert(typesInPayload[1] == int);\r\n    assert(typesInPayload[2] == double);\r\n    assert(typesInPayload[3] == bool);\r\n```\r\n\r\nBy importing the predicate library, you can start do a few more things. All the Predicates evaluate to True or False, True being yes and False being no.\r\n```dart\r\n    /// Predicate can help you answer some questions about the Tuple.\r\n\r\n    assert(isSepTuple(payload) == false); // No it does not have 7 elements.\r\n    assert(isQuadruple(payload) == true); // Yes it does have 4 elements\r\n    assert(isSexdecuple(payload) == false); // No it does not have 16 elements.\r\n    assert(isLeaf(deepLikeness) == false); // No one of elements is a Tuple.\r\n    assert(isLeaf(sameContent1) == true); // Yes, no other tuple are inside.\r\n    \r\n```\r\n\r\nUnfortunately life is never that clean, sometimes we want to partial match some elements in the Tuple and not be too fussed about the other types as long as they are present. To achieve this we use [Object] as a wildcard place holder.\r\n \r\n```dart\r\n   /// Looking inside for a pattern.\r\n     \r\n   Tuple strictPattern = new Tuple ([String, int, double, bool]);\r\n   Tuple loosePattern = new Tuple ([String, Object, double, Object]);\r\n   \r\n   assert (isTupleTypeMatched(payload, strictPattern) == true);\r\n   assert (isTupleTypeMatched(payload, loosePattern) == true);\r\n   \r\n   /// Sometimes you don't get what you want.\r\n   \r\n   Tuple expectedTuplePattern = new Tuple ([String, int, int, bool]);\r\n   assert(isTupleTypeMatched(payload, expectedTuplePattern) == false);\r\n   \r\n   /// Sometimes you don't get enough of what you want.\r\n   \r\n   Tuple veryLoosePattern = new Tuple ([Object, Object, Object, Object, Object]);\r\n   assert(isTupleTypeMatched(payload, veryLoosePattern) == false); \r\n```\r\n\r\nThings also have a way of being odd shaped, fuzzy around the edges or just not complete but we can live with it. To cater for this we bring [Optional] into play, it allows the element to be present or not present. Conditionally if it is present it can ensure that it is of a certain type. Both the wildcard and optional can be used in any position of in the pattern tuple.\r\n\r\n```dart\r\n   /// Real life is fuzzy\r\n   \r\n   Tuple acceptableStandard =\r\n       new Tuple([String, int, double, Object, new Optional.of(bool)]);\r\n   assert(isTupleTypeMatched(payload, acceptableStandard) == true);\r\n   \r\n   Tuple lowerStandard = new Tuple([String, new Optional.of(int), double, bool]);\r\n   assert(isTupleTypeMatched(payload, lowerStandard) == true);\r\n   \r\n   Tuple differentStandard = new Tuple([new Optional.of(String), int, double, bool]);\r\n   assert(isTupleTypeMatched(payload, differentStandard) == true);\r\n```\r\n\r\n#### Using Optional\r\n\r\n[Optional](https://www.dartdocs.org/documentation/quiver_optional/1.0.0-dev.1/quiver.optional/Optional-class.html) is from dart Quiver Library, it denotes an optional element. The semantics of this is expected to change\r\n  when [NNBD (Non-null Types & Non-null By Default)](https://github.com/chalin/DEP-non-null) lands in dart. At that time Optional is expected to be deprecated from Quiver. Until then\r\n  we use optional in a pattern tuple to represent and element that may or not be present (it is optional!). We further use Optional.absent()\r\n  if we don't really care about the type or value when the element is present.\r\n    \r\n  Using optional.of(T value) we can express the rule that states, the element does not have to be in the tuple, but if it include it must\r\n  be of T value.\r\n    \r\n  Should you expect to use this heavily it is worth understanding the [migration strategies](https://github.com/chalin/DEP-non-null/blob/master/doc/dep-non-null-AUTOGENERATED-DO-NOT-EDIT.md#part-migration) being currently being proposed. \r\n    \r\n\r\n### Limitations & Alternatives\r\n\r\n- This Package is not designed to deliver a collection of Tuple nor a classic tuple space.\r\n- [tuple](https://pub.dartlang.org/packages/tuple) provides stronger type implementation, has nice way to layer a tuple within a tuple.\r\n- [duty](https://pub.dartlang.org/packages/duty) provides more then a Tuple but does have type safe containers for a Monuple, Pairple and Triple.\r\n- [vacuum_persistent] (https://pub.dartlang.org/packages/vacuum_persistent) provide a complete persistence with immutable data structures.\r\n\r\nIf a packages should be on this list and is not, just add it via a pull request or rise an [issue](https://github.com/rayk/darpule/issues/new).","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}