<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="description" content="Darpule : Lightweight, robust immutable tuple implementation.">

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Darpule</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/rayk/darpule">View on GitHub</a>

          <h1 id="project_title">Darpule</h1>
          <h2 id="project_tagline">Lightweight, robust immutable tuple implementation.</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/rayk/darpule/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/rayk/darpule/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>
<a id="darpule" class="anchor" href="#darpule" aria-hidden="true"><span class="octicon octicon-link"></span></a>Darpule</h1>

<p><em>Lightweight, Robust Immutable Tuple Implementation.</em></p>

<p>The <a href="https://en.wikipedia.org/wiki/Tuple">tuple</a> has been knocking around for a long time, with implementations in Python, Lisp, Scala, Linda and many other languages it is the workhorse for sling data around between functions.</p>

<p>Immutability certain helps with persistence and being able to send it to an Isolate without the serialising and marshalling is handy.</p>

<p>This package attempts to address the base use case, which is the passing of multiple parameters and results in a clean, structured way, via a Tuple. The implementation wraps all the Dart Goodness to deliver lightweight implementation was possible.  </p>

<h3>
<a id="usage-examples" class="anchor" href="#usage-examples" aria-hidden="true"><span class="octicon octicon-link"></span></a>Usage Examples</h3>

<p><em>The code before can be run from examples/darpule.dart.</em></p>

<p>Just one easy way to create an immutable tuple with <em>n</em> elements. Using a single generative constructor, development time type checking was deliberately traded off. Insteadof using generics to parametrise multiple Tuple types, functional predicates where used for dynamic runtime type checking.</p>

<div class="highlight highlight-source-dart"><pre>    <span class="pl-c">/// Created in a very ad-hoc.</span>

    <span class="pl-k">List</span> resultFromSomeWhere <span class="pl-k">=</span> [<span class="pl-s">'Longhaul'</span>, <span class="pl-c1">382</span>, <span class="pl-c1">982.23</span>, <span class="pl-c1">false</span>];

    Tuple payload <span class="pl-k">=</span> <span class="pl-k">new</span> Tuple(resultFromSomeWhere);

    <span class="pl-k">assert</span>(payload <span class="pl-k">is</span> Tuple);
    <span class="pl-k">assert</span>(payload.type <span class="pl-k">==</span> TupleType.quadruple);
    <span class="pl-k">assert</span>(payload.elementCount <span class="pl-k">==</span> <span class="pl-c1">4</span>);

    <span class="pl-c">/// Tuple can hold anything.</span>
    Tuple collective <span class="pl-k">=</span> <span class="pl-k">new</span> Tuple([
      <span class="pl-c1">true</span>,
      <span class="pl-k">new</span> Tuple([<span class="pl-c1">343</span>, <span class="pl-c1">false</span>]),
      <span class="pl-k">new</span> DateTime.now()
    ]);

    <span class="pl-k">assert</span>(collective <span class="pl-k">is</span> Tuple);
    <span class="pl-k">assert</span>(collective.type <span class="pl-k">==</span> TupleType.triple);
</pre></div>

<p>So as not to reinvent the wheel the Tuple type just extends Dart's <a href="https://api.dartlang.org/134830/dart-collection/UnmodifiableListView-class.html">UnmodifiableListView</a>, which has a reasonably small footprint. This provides the iterator goodness for locating stuff. Just no modification after construction.</p>

<p>You can also just call the Tuple instance, and it returns a list of its elements that you can modify in any way. When ready pass that list back into a Tuple constructor, and we have a new immutable Tuple.</p>

<div class="highlight highlight-source-dart"><pre>    <span class="pl-c">/// Ways to get a tuple elements</span>

    Tuple notSameContent <span class="pl-k">=</span> <span class="pl-k">new</span> Tuple([<span class="pl-c1">8827</span>, <span class="pl-s">'sad'</span>]);

    <span class="pl-k">assert</span>(collective[<span class="pl-c1">0</span>] <span class="pl-k">==</span> <span class="pl-c1">true</span>); <span class="pl-c">// Using element position number.</span>

    <span class="pl-k">List</span> tupleContent <span class="pl-k">=</span> notSameContent(); <span class="pl-c">// Call your tuple like a function.</span>

    <span class="pl-k">assert</span>(tupleContent[<span class="pl-c1">0</span>] <span class="pl-k">==</span> <span class="pl-c1">8827</span> <span class="pl-k">&amp;&amp;</span> tupleContent[<span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-s">'sad'</span>);

    tupleContent.add(<span class="pl-s">'Now we can mutate the resulting list'</span>);

    Tuple notSameContentWithMore <span class="pl-k">=</span> <span class="pl-k">new</span> Tuple(tupleContent); <span class="pl-c">// Back to a tuple.</span>

    <span class="pl-k">assert</span> (notSameContentWithMore <span class="pl-k">is</span> Tuple);
    <span class="pl-k">assert</span> (notSameContent.type <span class="pl-k">==</span> TupleType.pairple);
    <span class="pl-k">assert</span> (notSameContentWithMore.type <span class="pl-k">==</span> TupleType.triple);</pre></div>

<p>Beside UnmodifiableList View not supporting mutations, we have introduced an [MutabilityError] just so you can blow up when something attempts mutate your tuple.</p>

<div class="highlight highlight-source-dart"><pre>    <span class="pl-c">/// Tuple is Immutable, trying results in an programming error.</span>

    <span class="pl-k">try</span> {
      payload.add(<span class="pl-s">'WantToAddElement'</span>);
    } <span class="pl-k">catch</span> (error) {
      <span class="pl-k">assert</span>(error <span class="pl-k">is</span> MutabilityError);
    }

    <span class="pl-k">try</span> {
      payload.addAll([<span class="pl-s">'doctor'</span>, <span class="pl-s">'drugs'</span>]);
    } <span class="pl-k">catch</span> (error) {
      <span class="pl-k">assert</span>(error <span class="pl-k">is</span> MutabilityError);
    }

    <span class="pl-k">try</span> {
      payload.removeAt(<span class="pl-c1">0</span>);
    } <span class="pl-k">catch</span> (error) {
      <span class="pl-k">assert</span> (error <span class="pl-k">is</span> MutabilityError);
    }</pre></div>

<p>Equal is based upon the content and structure of the tuple.</p>

<div class="highlight highlight-source-dart"><pre>    <span class="pl-c">/// Hash and Equals behaviour</span>

    <span class="pl-k">assert</span>(collective <span class="pl-k">!=</span> payload);

    Tuple sameContent1 <span class="pl-k">=</span> <span class="pl-k">new</span> Tuple([<span class="pl-c1">3902</span>, <span class="pl-s">'happy'</span>]);
    Tuple sameContent2 <span class="pl-k">=</span> <span class="pl-k">new</span> Tuple([<span class="pl-c1">3902</span>, <span class="pl-s">'happy'</span>]);

    <span class="pl-k">assert</span>(sameContent1 <span class="pl-k">==</span> sameContent2); <span class="pl-c">// They have same elements.</span>
    <span class="pl-k">assert</span>(identical(sameContent1, sameContent2) <span class="pl-k">==</span> <span class="pl-c1">false</span>); <span class="pl-c">// But are unique.</span>

    Tuple notSameContent <span class="pl-k">=</span> <span class="pl-k">new</span> Tuple([<span class="pl-c1">8827</span>, <span class="pl-s">'sad'</span>]);

    Tuple deepLikeness <span class="pl-k">=</span> <span class="pl-k">new</span> Tuple([<span class="pl-s">'skindeep'</span>, sameContent1]);
    Tuple deeperLikeness <span class="pl-k">=</span> <span class="pl-k">new</span> Tuple([<span class="pl-s">'skindeep'</span>, sameContent1]);
    Tuple downDeep <span class="pl-k">=</span> <span class="pl-k">new</span> Tuple([<span class="pl-s">'skindeep'</span>, notSameContent]);

    <span class="pl-k">assert</span>(deepLikeness <span class="pl-k">==</span> deeperLikeness);
    <span class="pl-k">assert</span>(downDeep <span class="pl-k">!=</span> deepLikeness);</pre></div>

<p>This is all very nice and neat, but the only type we have it is 'Tuple'. This is where predicates come into play. It easily to become a Tupleholic and when you end up with functions that accept any Tuple, a real mess can appear overnight. Hence the Predicate library, given that we have a list of typed elements within the tuple we may as well see what funky, functional things we can do.</p>

<p>Without importing the predicate library, you can use the [elementTypesOf(Tuple tuple)] to get a tuple of the element types as [Type].</p>

<div class="highlight highlight-source-dart"><pre>    <span class="pl-c">/// Finding out what the elements are at runtime.</span>

    Tuple typesInPayload <span class="pl-k">=</span> elementTypesOf(payload);

    <span class="pl-k">assert</span>(typesInPayload[<span class="pl-c1">0</span>] <span class="pl-k">==</span> <span class="pl-k">String</span> );
    <span class="pl-k">assert</span>(typesInPayload[<span class="pl-c1">1</span>] <span class="pl-k">==</span> <span class="pl-k">int</span>);
    <span class="pl-k">assert</span>(typesInPayload[<span class="pl-c1">2</span>] <span class="pl-k">==</span> <span class="pl-k">double</span>);
    <span class="pl-k">assert</span>(typesInPayload[<span class="pl-c1">3</span>] <span class="pl-k">==</span> <span class="pl-k">bool</span>);</pre></div>

<p>By importing the predicate library, you can start do a few more things. All the Predicates evaluate to True or False, True being yes and False being no.</p>

<div class="highlight highlight-source-dart"><pre>    <span class="pl-c">/// Predicate can help you answer some questions about the Tuple.</span>

    <span class="pl-k">assert</span>(isSepTuple(payload) <span class="pl-k">==</span> <span class="pl-c1">false</span>); <span class="pl-c">// No it does not have 7 elements.</span>
    <span class="pl-k">assert</span>(isQuadruple(payload) <span class="pl-k">==</span> <span class="pl-c1">true</span>); <span class="pl-c">// Yes it does have 4 elements</span>
    <span class="pl-k">assert</span>(isLeaf(deepLikeness) <span class="pl-k">==</span> <span class="pl-c1">false</span>); <span class="pl-c">// No one of elements is a Tuple.</span>
    <span class="pl-k">assert</span>(isLeaf(sameContent1) <span class="pl-k">==</span> <span class="pl-c1">true</span>); <span class="pl-c">// Yes, no other tuple are inside.</span></pre></div>

<p>Unfortunately life is never that clean, sometimes we want to partial match some elements and we happy if other are are whatever type. To achieve this we use [Object] as a wildcard place holder.</p>

<div class="highlight highlight-source-dart"><pre>   <span class="pl-c">/// Looking inside for a pattern.</span>

   Tuple strictPattern <span class="pl-k">=</span> <span class="pl-k">new</span> Tuple ([<span class="pl-k">String</span>, <span class="pl-k">int</span>, <span class="pl-k">double</span>, <span class="pl-k">bool</span>]);
   Tuple loosePattern <span class="pl-k">=</span> <span class="pl-k">new</span> Tuple ([<span class="pl-k">String</span>, Object, <span class="pl-k">double</span>, Object]);

   <span class="pl-k">assert</span> (isTupleTypeMatched(payload, strictPattern) <span class="pl-k">==</span> <span class="pl-c1">true</span>);
   <span class="pl-k">assert</span> (isTupleTypeMatched(payload, loosePattern) <span class="pl-k">==</span> <span class="pl-c1">true</span>);

   <span class="pl-c">/// Sometimes you don't get what you want.</span>

   Tuple expectedTuplePattern <span class="pl-k">=</span> <span class="pl-k">new</span> Tuple ([<span class="pl-k">String</span>, <span class="pl-k">int</span>, <span class="pl-k">int</span>, <span class="pl-k">bool</span>]);
   <span class="pl-k">assert</span>(isTupleTypeMatched(payload, expectedTuplePattern) <span class="pl-k">==</span> <span class="pl-c1">false</span>);

   <span class="pl-c">/// Sometimes you don't get enough of what you want.</span>

   Tuple veryLoosePattern <span class="pl-k">=</span> <span class="pl-k">new</span> Tuple ([Object, Object, Object, Object, Object]);
   <span class="pl-k">assert</span>(isTupleTypeMatched(payload, veryLoosePattern) <span class="pl-k">==</span> <span class="pl-c1">false</span>); </pre></div>

<p>Things also have a way of being odd shaped, fuzzy around the edges or just not complete but we can live with it. So we bring [Optional] into play, it allows the element to be present or not present. Conditionally if it is present it we can ensure that is of a certain type.</p>

<div class="highlight highlight-source-dart"><pre>   <span class="pl-c">/// Real life is fuzzy</span>

   Tuple acceptableStandard <span class="pl-k">=</span>
       <span class="pl-k">new</span> Tuple([<span class="pl-k">String</span>, <span class="pl-k">int</span>, <span class="pl-k">double</span>, Object, <span class="pl-k">new</span> Optional.of(<span class="pl-k">bool</span>)]);
   <span class="pl-k">assert</span>(isTupleTypeMatched(payload, acceptableStandard) <span class="pl-k">==</span> <span class="pl-c1">true</span>);</pre></div>

<h3>
<a id="limitations--alternatives" class="anchor" href="#limitations--alternatives" aria-hidden="true"><span class="octicon octicon-link"></span></a>Limitations &amp; Alternatives</h3>

<ul>
<li>This Package is not designed to deliver a collection of Tuple nor a classic tuple space.</li>
<li>
<a href="https://pub.dartlang.org/packages/tuple">tuple</a> provides stronger type implementation, has nice way to layer a tuple within a tuple.</li>
<li>
<a href="https://pub.dartlang.org/packages/duty">duty</a> provides more then a Tuple but does have type safe containers for a Monuple, Pairple and Triple.</li>
<li>
<a href="https://pub.dartlang.org/packages/vacuum_persistent">vacuum_persistent</a> provide a complete persistence with immutable data structures.</li>
</ul>

<p>If a packages should be on this list and is not, just add it via a pull request or rise an <a href="https://github.com/rayk/darpule/issues/new">issue</a>.</p>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Darpule maintained by <a href="https://github.com/rayk">rayk</a></p>
        <p>Published with <a href="https://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
